{"version":3,"sources":["../../src/blots/image.ts","../../src/utils/index.ts","../../src/interfaces.ts","../../src/index.ts","App.tsx","index.tsx"],"names":["src","node","image","document","createElement","setAttribute","appendChild","domNode","getAttribute","parchment","EmbedBlot","blotName","className","tagName","ImageStatus","url2Img","url","Promise","resolve","reject","img","Image","crossOrigin","onload","onerror","img2Blob","text","x","y","font","fillStyle","imgAlpha","textAlpha","textAlign","canvas","width","height","ctx","getContext","globalAlpha","drawImage","save","fillText","toBlob","blob","isImageOp","op","insert","getImageUrlOfOp","isDataURL","s","test","quill","options","this","Delta","import","register","altMap","Map","urlMap","handleDrop","bind","handlePaste","root","addEventListener","injectUploaderHandler","getModule","handler","range","files","promises","map","upload","all","then","images","update","reduce","delta","retain","index","delete","length","updateContents","setSelection","e","clipboardData","types","includes","restoreImages","allowList","imageDomainAllowList","window","location","hostname","URL","a","originalUrl","shouldImageRestore","imageElement","querySelector","console","warn","attributes","set","alt","cachedUrl","get","modifyImageDelta","SUCCESS","LOADING","file","targetUrl","ERROR","getContents","i","ops","restoreImage","status","findIndex","_op","newOp","newDelta","slice","setContents","Quill","Quill2ImageDropAndPaste","mockUpload","setTimeout","App","props","quillInstance","useRef","useEffect","current","modules","toolbar","imageDropAndPaste","history","userOnly","placeholder","readOnly","theme","style","margin","href","id","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.9b2dca55.chunk.js","sourcesContent":["import parchment from 'parchment';\n\n// import Quill from 'quill';\n\n// const { InlineBlot } = Quill.import('parchment');\n// const Embed = Quill.import('blots/embed');\n// const InlineBlot = Quill.import('blots/inline');\n\nclass LoadingImage extends parchment.EmbedBlot {\n  static create(src: string) {\n    const node = super.create(src);\n\n    const image = document.createElement('img');\n    image.setAttribute('src', src);\n    node.appendChild(image);\n    node.setAttribute('data-src', src);\n    return node;\n  }\n\n  static value(domNode: HTMLParagraphElement) {\n    return domNode.getAttribute('data-src') || '';\n  }\n}\n\nLoadingImage.blotName = 'loading-iamge';\nLoadingImage.className = 'ql-image-uploading';\nLoadingImage.tagName = 'SECTION';\n\nexport default LoadingImage;\n","import { Op } from '../interfaces';\n\nexport const url2Img = (url: string): Promise<HTMLImageElement> => new Promise(\n  (resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    img.src = url;\n    img.onload = (): void => {\n      resolve(img);\n    };\n    img.onerror = reject;\n  },\n);\n\n/**\n * 使用 Canvas 将图片 url 转为带 水印的 Blob\n * @param img Image 实例\n * @param watermarkOptions 水印选项\n * @param watermarkOptions text 水印文本内容\n * @param watermarkOptions x x轴位置\n * @param watermarkOptions y y轴位置\n * @param watermarkOptions font 水印文本字体\n * @param watermarkOptions fillStyle 水印文本样式\n * @param watermarkOptions imgAlpha 图片透明度 0~1\n * @param watermarkOptions textAlpha 水印文本透明度 0~1\n * @param watermarkOptions textAlign 水印文本对齐方式\n */\nexport const img2Blob = (img: HTMLImageElement, {\n  text = '',\n  x = 0,\n  y = 0,\n  font = '24px serif',\n  fillStyle = 'red',\n  imgAlpha = 1,\n  textAlpha = 1,\n  textAlign = 'center' as CanvasTextAlign,\n}): Promise<Blob> => new Promise(\n  (resolve, reject) => {\n    if (!img) {\n      reject();\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      return;\n    }\n    ctx.globalAlpha = imgAlpha;\n    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n    ctx.save();\n    if (text) {\n      ctx.globalAlpha = textAlpha;\n      ctx.font = font;\n      ctx.fillStyle = fillStyle;\n      ctx.textAlign = textAlign;\n      ctx.fillText(text, x || canvas.width / 2, y || canvas.height / 2);\n    }\n    canvas.toBlob((blob) => resolve(blob as Blob));\n  },\n);\n\nexport const isImageOp = (op: Op): boolean => {\n  if (op.insert === 'undefined' || typeof op.insert === 'string') {\n    return false;\n  }\n\n  const insert = op.insert as { image?: string, ['loading-iamge']?: string };\n  return typeof (insert.image || insert['loading-iamge']) === 'string';\n};\n\nexport const getImageUrlOfOp = (op: Op): string => {\n  if (typeof op.insert === 'object') {\n    const insert = op.insert as { image?: string, ['loading-iamge']?: string };\n    return insert.image || insert['loading-iamge'] || '';\n  }\n  return '';\n};\n\nexport const isDataURL = (s: string): boolean => /^data:image\\/.+;base64/.test(s);\n","import Quill from 'quill';\n\nexport interface Options {\n  upload(file: Blob): Promise<string>;\n  imageDomainAllowList?: string[];\n}\n\nexport abstract class QuillImageDropAndPaste {\n  public quill;\n\n  public options: Options;\n\n  public constructor(quill: Quill, options: Options) {\n    this.quill = quill;\n    this.options = options;\n  }\n\n  protected abstract handleDrop(e: DragEvent): void;\n\n  protected abstract handlePaste(e: ClipboardEvent): void;\n}\n\nexport interface Op {\n  // only one property out of {insert, delete, retain} will be present\n  insert?: string | object;\n  delete?: number;\n  retain?: number;\n  attributes?: AttributeMap;\n}\n\nexport interface AttributeMap {\n  [key: string]: any;\n}\n\nexport enum ImageStatus {\n  LOADING = 'loading',\n  SUCCESS = 'success',\n  ERROR = 'error',\n}\n","import Quill, { RangeStatic } from 'quill';\nimport LoadingImage from './blots/image';\nimport {\n  img2Blob, isImageOp, getImageUrlOfOp, isDataURL, url2Img,\n} from './utils';\nimport {\n  QuillImageDropAndPaste, Options, Op, ImageStatus,\n} from './interfaces';\n\nconst Delta = Quill.import('delta');\n\n// TODO: this is an invalid usage\nQuill.register({ 'formats/loading-image': LoadingImage }, true);\n\nclass ImageDropAndPaste extends QuillImageDropAndPaste {\n  quill: Quill;\n\n  options: Options;\n\n  private altMap = new Map<string, string>();\n\n  private urlMap = new Map<string, string>();\n\n  constructor(quill: Quill, options: Options) {\n    super(quill, options);\n    this.quill = quill;\n    this.options = options;\n\n    this.handleDrop = this.handleDrop.bind(this);\n    this.handlePaste = this.handlePaste.bind(this);\n    this.quill.root.addEventListener('drop', this.handleDrop, false);\n    this.quill.root.addEventListener('paste', this.handlePaste, false);\n    this.injectUploaderHandler();\n  }\n\n  /**\n   * With quill2 editor, you should only set options.handler of uploader module.\n   * It will automatically replace images from dataurl to url via your custom image handler.\n   * Related issue: https://github.com/quilljs/quill/issues/863#issuecomment-240579430\n   *\n   * Source code for handling paste event: https://github.com/quilljs/quill/blob/d2bd71d758dd0bb707801ca3e07b9919ece748ca/modules/uploader.js#L8\n   * Source code for handling drop event: https://github.com/quilljs/quill/blob/d2bd71d758dd0bb707801ca3e07b9919ece748ca/modules/clipboard.js#L156\n   */\n  injectUploaderHandler() {\n    const imageHandler = (range: RangeStatic, files: Blob[]) => {\n      const promises = files.map(this.options.upload);\n      Promise.all(promises).then((images) => {\n        const update = images.reduce(\n          (delta, image) => delta.insert({ image }),\n          new Delta().retain(range.index).delete(range.length),\n        );\n        this.quill.updateContents(update, 'user');\n        this.quill.setSelection(\n          range.index + images.length,\n          0,\n          'silent',\n        );\n      });\n    };\n    const uploader = this.quill\n      .getModule('uploader');\n    uploader.options.handler = imageHandler;\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  handleDrop(e: DragEvent): void {\n    // TODO: elegant implements for paste or drop images / videos\n  }\n\n  handlePaste(e: ClipboardEvent): void {\n    if (!e.clipboardData) {\n      return;\n    }\n    if (e.clipboardData.types.includes('text/html') && !e.clipboardData.types.includes('Files')) {\n      this.restoreImages();\n    }\n  }\n\n  shouldImageRestore(url: string) {\n    const allowList = this.options.imageDomainAllowList || [window.location.hostname];\n    if (isDataURL(url)) {\n      return true;\n    }\n    const { hostname } = new URL(url);\n    return !allowList.includes(hostname);\n  }\n\n  async restoreImage(op: Op): Promise<void> {\n    const originalUrl = getImageUrlOfOp(op);\n    if (!this.shouldImageRestore(originalUrl)) {\n      return;\n    }\n    try {\n      const imageElement = !isDataURL(originalUrl)\n        ? this.quill.root.querySelector(`img[src=\"${originalUrl}\"]`)\n        : url2Img(originalUrl);\n      if (!imageElement) {\n        console.warn('Can not read img element of url: %s', originalUrl);\n        return;\n      }\n      const { attributes } = op;\n      // TODO: base64 encode image has a too large string length\n      this.altMap.set(originalUrl, attributes?.alt || '');\n      const cachedUrl = this.urlMap.get(originalUrl);\n      if (typeof cachedUrl === 'string') {\n        this.modifyImageDelta(originalUrl, cachedUrl, ImageStatus.SUCCESS);\n        return;\n      }\n      this.modifyImageDelta(originalUrl, '', ImageStatus.LOADING);\n      const file = await img2Blob(imageElement as HTMLImageElement, {});\n      const targetUrl = await this.options.upload(file);\n      this.urlMap.set(originalUrl, targetUrl);\n      this.modifyImageDelta(originalUrl, targetUrl, ImageStatus.SUCCESS);\n    } catch (error) {\n      console.warn(error);\n      this.modifyImageDelta(originalUrl, '', ImageStatus.ERROR);\n    }\n  }\n\n  restoreImages() {\n    const delta = this.quill.getContents();\n    for (let i = 0; i < delta.ops.length; i += 1) {\n      const op = delta.ops[i];\n      // Replace original url to target url\n      if (isImageOp(op)) {\n        this.restoreImage(op);\n      }\n    }\n  }\n\n  async modifyImageDelta(originalUrl: string, targetUrl: string, status: ImageStatus) {\n    const delta = this.quill.getContents();\n    const index = delta.ops.findIndex(\n      (_op: Op) => isImageOp(_op) && getImageUrlOfOp(_op) === originalUrl,\n    );\n    const { attributes } = delta.ops[index] || {};\n    const alt = status === ImageStatus.SUCCESS\n      ? this.altMap.get(originalUrl)\n      : status;\n    const newOp: Op = {\n      attributes: {\n        ...(attributes || {}),\n        alt,\n      },\n      insert: {\n        image: targetUrl || originalUrl,\n      },\n      // insert: status !== ImageStatus.LOADING\n      //   ? {\n      //     image: targetUrl || originalUrl,\n      //   }\n      //   : {\n      //     [LoadingImage.blotName]: originalUrl,\n      //   },\n    };\n    // const previousDelta = new Delta(delta.ops.slice(0, index));\n    // const previousLength = previousDelta.length();\n    // const newDelta = new Delta().retain(previousLength + 1).delete(1).insert(newOp);\n    const newDelta = new Delta([\n      ...delta.ops.slice(0, index),\n      newOp,\n      ...delta.ops.slice(index + 1),\n    ]);\n    this.quill.setContents(newDelta, 'api');\n  }\n}\n\nexport default ImageDropAndPaste;\n\nexport {\n  LoadingImage,\n};\n","import React, { useRef, useEffect } from 'react';\n// @ts-ignore\nimport Quill2ImageDropAndPaste from 'quill2-image-drop-and-paste';\nimport Quill from 'quill';\n\nimport 'quill/dist/quill.snow.css';\nimport './index.css';\n\nQuill.register('modules/imageDropAndPaste', Quill2ImageDropAndPaste);\n\nconst mockUpload = (file: Blob) => new Promise(resolve => {\n  // TODO: uploader\n  const url = 'https://cdn.nlark.com/yuque/0/2021/jpeg/103147/1637414393290-33a1c232-f002-44ab-b52b-c2f61d193965.jpeg?x-oss-process=image%2Fresize%2Cw_750%2Climit_0';\n  setTimeout(() => resolve(url), 5000);\n});\n\nconst App: React.FC<{}> = (props) => {\n  const quillInstance = useRef<Quill>();\n\n  useEffect(() => {\n    if (quillInstance.current) {\n      return;\n    }\n    const quill = new Quill('#editor-container', {\n      modules: {\n        toolbar: [['bold', 'italic'], ['link', 'image']],\n        imageDropAndPaste: {\n          upload: mockUpload,\n          imageDomainAllowList: [\n            'cdn.nlark.com'\n          ]\n        },\n        history: {\n          userOnly: true,\n        },\n      },\n      placeholder: 'Copy & paste, or drag an image here...',\n      readOnly: false,\n      theme: 'snow'\n    });\n    quillInstance.current = quill;\n  }, []);\n\n  return (\n    <div className=\"App\" style={{ width: 960, margin: 'auto' }}>\n      <h1>React Example</h1>\n      <p>Back to <a href=\"https://github.com/x-cold/quill2-image-drop-and-paste\">homepage</a> of quill2-image-drop-and-paste</p>\n      <div id=\"editor-container\" style={{ height: '640px' }}></div>\n      <p>The image uploader is mocked function, and the image url will consistently change to: <br /> 'https://cdn.nlark.com/yuque/0/2021/jpeg/103147/1637414393290-33a1c232-f002-44ab-b52b-c2f61d193965.jpeg?x-oss-process=image%2Fresize%2Cw_750%2Climit_0'</p>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}